# Day Seven

## Section

```elixir
Mix.install([
  {:kino, "~> 0.11.3"}
])
```

```elixir
defmodule Utilities do
  @moduledoc """
  Provides utility functions to be used across days
  """

  def read_data(day) do
    day_as_string =
      day
      |> Integer.to_string()
      |> String.pad_leading(2, "0")

    Path.join(__DIR__, "../data/day_#{day_as_string}_input.txt")
    |> Path.expand()
    |> File.read!()
  end

  def to_list(big_string) do
    String.split(big_string, "\n")
  end
end
```

```elixir
defmodule Counter do
  use Agent

  def start_link(initial_value) do
    Agent.start_link(fn -> initial_value end, name: __MODULE__)
  end

  def stop() do
    Agent.stop(__MODULE__, :normal, :infinity)
  end

  def value do
    Agent.get(__MODULE__, & &1)
  end

  def increment do
    Agent.update(__MODULE__, &(&1 + 1))
  end

  def increase_by_value(value) do
    Agent.update(__MODULE__, &(&1 + value))
  end
end
```

#### Day 7: Laboratories

You thank the cephalopods for the help and exit the trash compactor, finding yourself in the familiar halls of a North Pole research wing.

Based on the large sign that says "teleporter hub", they seem to be researching teleportation; you can't help but try it for yourself and step onto the large yellow teleporter pad.

Suddenly, you find yourself in an unfamiliar room! The room has no doors; the only way out is the teleporter. Unfortunately, the teleporter seems to be leaking magic smoke.

Since this is a teleporter lab, there are lots of spare parts, manuals, and diagnostic equipment lying around. After connecting one of the diagnostic tools, it helpfully displays error code 0H-N0, which apparently means that there's an issue with one of the tachyon manifolds.

You quickly locate a diagram of the tachyon manifold (your puzzle input). A tachyon beam enters the manifold at the location marked S; tachyon beams always move downward. Tachyon beams pass freely through empty space (.). However, if a tachyon beam encounters a splitter (^), the beam is stopped; instead, a new tachyon beam continues from the immediate left and from the immediate right of the splitter.

For example:

```
.......S.......
...............
.......^.......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............
```

In this example, the incoming tachyon beam (|) extends downward from S until it reaches the first splitter:

```
.......S.......
.......|.......
.......^.......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............
```

At that point, the original beam stops, and two new beams are emitted from the splitter:

```
.......S.......
.......|.......
......|^|......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............
```

Those beams continue downward until they reach more splitters:

```
.......S.......
.......|.......
......|^|......
......|.|......
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............
```

At this point, the two splitters create a total of only three tachyon beams, since they are both dumping tachyons into the same place between them:

```
.......S.......
.......|.......
......|^|......
......|.|......
.....|^|^|.....
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............
```

This process continues until all of the tachyon beams reach a splitter or exit the manifold:

```
.......S.......
.......|.......
......|^|......
......|.|......
.....|^|^|.....
.....|.|.|.....
....|^|^|^|....
....|.|.|.|....
...|^|^|||^|...
...|.|.|||.|...
..|^|^|||^|^|..
..|.|.|||.|.|..
.|^|||^||.||^|.
.|.|||.||.||.|.
|^|^|^|^|^|||^|
|.|.|.|.|.|||.|
```

To repair the teleporter, you first need to understand the beam-splitting properties of the tachyon manifold. In this example, a tachyon beam is split a total of 21 times.

Analyze your manifold diagram. How many times will the beam be split?

```elixir
practice_input = [
  ".......S.......",
  "...............",
  ".......^.......",
  "...............",
  "......^.^......",
  "...............",
  ".....^.^.^.....",
  "...............",
  "....^.^...^....",
  "...............",
  "...^.^...^.^...",
  "...............",
  "..^...^.....^..",
  "...............",
  ".^.^.^.^.^...^.",
  "..............."
]

puzzle_input = Utilities.read_data(7) |> Utilities.to_list()
puzzle_input = practice_input
```

```elixir
defmodule DaySeven do
  # we're going to have to track beam indicies
  def part_one(puzzle_input) do
    Counter.start_link(0)
    puzzle_input = 
      puzzle_input
      |> Enum.map(fn row -> String.codepoints(row) end)
      
    index = find_beam_start_index(puzzle_input)
    beam_indexes = [index]
    {_first, rest_of_puzzle} = List.pop_at(puzzle_input, 0)

    trace_beam_path(rest_of_puzzle, beam_indexes)
    
    Counter.value() |> IO.inspect(label: "Beam was split this many times: ")
    Counter.stop()
  end

  # def part_two(puzzle_input) do
  #   puzzle_input = 
  #     puzzle_input
  #     |> Enum.map(fn row -> String.codepoints(row) end)
  #     |> Enum.map(fn row -> Enum.filter(row, fn slot -> slot == "^" end)end) 
  #     |> Enum.map(fn row -> Enum.map(row, fn slot -> 1 end)end) 
  #     |> List.flatten()
  #     |> Enum.sum()
  # end

  def trace_beam_path(puzzle, beam_indexes) do
    Enum.reduce(puzzle, beam_indexes, fn row, beam_indexes -> 
      
      {new_row, new_indexes} = draw_beam(row, beam_indexes)
      IO.inspect(new_row)
      IO.inspect(new_indexes, label: :new_indexes, charlists: :as_list)
      new_indexes
      end)
    

  end

  def draw_beam(row, beam_indexes) do
    row
    |> Enum.with_index()
    |> Enum.reduce({[],[]}, fn {slot, index}, {new_row, new_indexes} -> 
      if index in beam_indexes do
        if slot == "^" do
          # adjust beam index
          Counter.increment()
          {["|" | new_row], [index - 1 , index + 1 | new_indexes]}
        else
          {["|" | new_row], [index | new_indexes]}
        end
      else
        {["." | new_row], new_indexes}
      end
      end)
  end

  def find_beam_start_index(puzzle_input) do
    first_row = Enum.at(puzzle_input, 0)
    
    Enum.find_index(first_row, fn element -> 
      element == "S"
    end)
  end
end
```

```elixir
DaySeven.part_one(puzzle_input)
```
